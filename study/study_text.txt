<< 매장 테이블 예약 서비스 >>


=============================== << ERD 작성 >> ===============================
- ERD 관계선 참고 블로그
  : https://eyecandyzero.tistory.com/246

1. JPA Entity에서 id를 int가 아닌 long 타입으로 선언하는 이유
   - 참고블로그 : https://lealea.tistory.com/237
   - 위의 글을 참고해 mysql의 id는 int, java의 entity는 long 타입으로 선언.
     (이렇게되면 데이터의 범위는 int까지 저장가능.)





=============================== << 비즈니스 프로세스 작성 >> ===============================
- 참고블로그
  : https://www.edrawsoft.com/kr/article/how-to-create-bpmn-diagram.html





=============================== << JPA >> ===============================
1. @MappedSuperclass
   : 객체 입장에서 공통 매핑 정보 필요 시 사용.
     공통 매핑 정보 필요 시, 부모 클래스에 선언하고 속성만 상속받아 사용하고 싶을 때 사용.
   - 해당 어노테이션이 선언되어 있는 클래스는 엔티티가 아니다.
     따라서 테이블과 별도로 매핑되지 않는다.
   - 직접 생성해 사용할 일이 없으므로 추상 클래스로 만드는 것이 권장된다.
   - JPA에서 @Entity 클래스는 @Entity 클래스 또는 @MappedSuperclass로 지정한 클래스만 상속가능.

   ex) 생성자, 생성시간, 수정자, 수정시간 등

  - 참고 블로그
    : https://ict-nroo.tistory.com/129


2. @EntityListeners(value={AuditingEntityListener.class})
   : 해당 클래스에 Auditing 기능을 포함.

   - JPA Auditing 활성화
     : @SpringBootApplication 어노테이션이 있는 Application.java 파일에 @EnableJpaAuditing 어노테이션을 추가해
       JPA Auditing 기능을 활성화 해야 사용가능.

   - JPA의 Auditing
     : JPA에서는 Audit 기능을 제공한다.
       Audit은 spring data JPA에서 시간에 대해 자동으로 값을 넣어주는 기능이다.
       도메일을 영속성 컨텍스트에 저장하거나 조회를 수행한 후 update 하는 경우 매번 시간 데이터를 입력해주어야하는데
       이 때 자동으로 시간을 매핑하여 데이터베이스의 테이블을 넣어주게 된다.

   - @CreatedDate : Entity가 생성되어 저장될 때 시간 자동 저장.
   - @LastModifiedDate : 조회한 Entity의 값을 변경할 때 시간 자동 저장.

   - 참고 블로그
     : https://webcoding-start.tistory.com/53





=============================== << @Transactional 사용시 DB에 자동저장 되지않는 문제 >> ===============================
- 발생문제
  @Transactional 자동 save, update 되지 않는 오류.
  : @Transactional 어노테이션을 이용하면 자동으로 DB에 저장된다고 알고있었다.
    Dirty Checking은 find~ 메서드 호출 후 snapshot을 찍어 해당 Entity의 변경 사항이 발생했는지 확인한다.
    나는 find 하지 않았기 때문에 Dirty Checking이 수행되지 않았다.
    그런데 save 호출 후 find한 뒤에 변경해도 Dirty Checking을 수행하지 않았다... 왜지..

  - 관련 내용 : JPA 와 영속성 (Dirty Checking)
https://velog.io/@aj4941/Transactional%EA%B3%BC-%EB%B3%80%EA%B2%BD-%EA%B0%90%EC%A7%80-Dirty-Checking
https://junior-datalist.tistory.com/349
https://velog.io/@yeongori/Dirty-Checking-is-Not-Working

- 발생원인
  : 기존 데이터 null값, 변경된 데이터도 null값이었기 때문에 실질적으로 변경사항이 전혀 없어서 update되지 않음.

- 해결방법
  : 실제 데이터를 변경해주니 정상동작했다.




